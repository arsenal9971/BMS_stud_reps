(function() {

/* PHP dump data for JS script */
var data = {
    "collection": [
        "opensource"
    ],
    "streamOnly": false,
    "use_title_for_side": null,
    "id": "MathematicsCanBeFun-1",
    "server": "ia600804.us.archive.org",
    "subPrefix": "MathematicsCanBeFun1",
    "subItemPath": "\/1\/items\/MathematicsCanBeFun-1\/MathematicsCanBeFun1",
    "bookTitle": "mathematics can be fun-1",
    "creator": "YAKOV PERELMAN",
    "publishDate": "",
    "language": "",
    "bookreaderDefaults": "",
    "archiveFormat": "zip",
    "imageStackFile": "\/1\/items\/MathematicsCanBeFun-1\/MathematicsCanBeFun1_jp2.zip",
    "imageFormat": "jp2",
    "titleLeaf": "4",
    "lendingInfo": {
        "userid": 0,
        "isAdmin": false,
        "isArchiveOrgLending": false,
        "isOpenLibraryLending": false,
        "isLendingRequired": false,
        "isBrowserBorrowable": false,
        "isAvailable": false,
        "userHasBorrowed": false,
        "userOnWaitingList": false,
        "userHoldIsReady": false,
        "shouldProtectImages": false,
        "daysLeftOnLoan": 0,
        "loansUrl": "",
        "bookUrl": "",
        "loanCount": 0,
        "maxLoans": 5
    },
    "imagesBaseURL": "\/bookreader\/BookReader\/images\/",
    "olHost": "https:\/\/openlibrary.org",
    "bookUrl": "\/details\/MathematicsCanBeFun-1",
    "bookUrlText": " &larr; Back to item details",
    "bookUrlTitle": "Go to this book's page on Archive.org",
    "moreInfoUrlText": "More information on Archive.org",
    "pageProgression": "lr",
    "downloadUrls": [
        [
            "PDF",
            "\/\/archive.org\/download\/MathematicsCanBeFun-1\/MathematicsCanBeFun1.pdf"
        ],
        [
            "ePub",
            "\/\/archive.org\/download\/MathematicsCanBeFun-1\/MathematicsCanBeFun1.epub"
        ],
        [
            "Plain Text",
            "\/\/archive.org\/download\/MathematicsCanBeFun-1\/MathematicsCanBeFun1_djvu.txt"
        ],
        [
            "DAISY",
            "\/\/archive.org\/download\/MathematicsCanBeFun-1\/MathematicsCanBeFun1_daisy.zip"
        ],
        [
            "Kindle",
            "\/\/archive.org\/download\/MathematicsCanBeFun-1\/MathematicsCanBeFun1.mobi"
        ]
    ],
    "pageW": [
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550,
        2550
    ],
    "pageH": [
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301,
        3301
    ],
    "leafMap": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        62,
        63,
        64,
        65,
        66,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        92,
        93,
        94,
        95,
        96,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        123,
        124,
        125,
        126,
        127,
        128,
        129,
        130,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        139,
        140,
        141,
        142,
        143,
        144,
        145,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        155,
        156,
        157,
        158,
        159,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        174,
        175,
        176,
        177,
        178,
        179,
        180,
        181,
        182,
        183,
        184,
        185
    ],
    "pageNums": [
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null
    ]
};

// Error reporting - this helps us fix errors quickly
function logError(description,page,line) {
  if (typeof(window.archive_analytics) != 'undefined') {
    var values = {
      'bookreader': 'error',
      'description': description,
      'page': page,
      'line': line,
      'itemid': data.id,
      'subPrefix': data.subPrefix,
      'server': data.server,
      'bookPath': data.subItemPath
    };

    // if no referrer set '-' as referrer
    if (document.referrer == '') {
      values['referrer'] = '-';
    } else {
      values['referrer'] = document.referrer;
    }

    if (typeof(br) != 'undefined') {
      values['itemid'] = br.bookId;
      values['subPrefix'] = br.subPrefix;
      values['server'] = br.server;
      values['bookPath'] = br.bookPath;
    }
    archive_analytics.send_ping(values);
  }
  return false; // allow browser error handling so user sees there was a problem
}
window.onerror = logError;

// function to manage the raven-js sentry agent
function setupRaven(identifier) {
  jQuery.getScript('/bookreader/BookReader/raven.min.js', function() {
    var options = { logger: 'BookReader' };
    var url = 'https://4a322a3bd5d44db5b941b28837d0b475@books-sentry.us.archive.org/7';
    Raven.config(url, options).install();
    var width = window.innerWidth ||
        document.documentElement.clientWidth ||
        document.body.clientWidth;
    var height = window.innerHeight ||
        document.documentElement.clientHeight ||
        document.body.clientHeight;
    Raven.setExtraContext({ book_identifier: identifier,
                           viewportWidth: width,
                           viewportHeight: height, });
  });
}


function add_query_param(url, name, value) {
  // Use & if the url already has some query parameters.
  // Use ? otherwise.
  var prefix = (url.indexOf("?") >= 0) ? "&" : "?";
  return url + prefix + name + "=" + value;
}

/**
 * Function to get the parameters from the URL
 * it returns param's value if param is defined
 */
function get_query_param(param) {
  var pageUrl   = window.location.search.substring(1);
  var paramsUrl = pageUrl.split('&');
  for (var i = 0; i < paramsUrl.length; i++) {
    var pName = paramsUrl[i].split('=');
    if (pName[0] == param) {
      return pName[1];
    }
  }
};


/**
 * @return {boolean} is this running in an iframe?
 */
function isInIframe() {
  try {
    return window.self !== window.top;
  } catch (e) {
    return true;
  }
};


function deleteLoanCookies(identifier) {
  var date = new Date();
  date.setTime(date.getTime()-(24*60*60*1000));  //one day ago
  var expiry = date.toGMTString();
  var cookie = 'loan-'+ identifier +'=""';
  cookie    += '; expires='+expiry;
  cookie    += '; path=/; domain=.archive.org;';
  document.cookie = cookie;

  cookie = 'br-loan-'+ identifier +'=""';
  cookie    += '; expires='+expiry;
  cookie    += '; path=/; domain=.archive.org;';
  document.cookie = cookie;
}

/**
 * urlencode everything in $path except any embedded slashes
 */
function urlencodePath(path) {
  var parts = path.split('/');
  for (var i = 0; i < parts.length; i++) {
    parts[i] = encodeURIComponent(parts[i]);
  }
  return parts.join('/');
}


/**
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 */
if (typeof Object.assign != 'function') {
  (function () {
    Object.assign = function (target) {
      'use strict';
      // We must check against these specific cases.
      if (target === undefined || target === null) {
        throw new TypeError('Cannot convert undefined or null to object');
      }
      var output = Object(target);
      for (var index = 1; index < arguments.length; index++) {
        var source = arguments[index];
        if (source !== undefined && source !== null) {
          for (var nextKey in source) {
            if (source.hasOwnProperty(nextKey)) {
              output[nextKey] = source[nextKey];
            }
          }
        }
      }
      return output;
    };
  })();
}

var buildActionButton = function(action) {
  if (!action) {
    return;
  }
  var $el = $("<button>")
  .html(action.text)
  .addClass("action")
  .click(function() {
    action.callback.call();
  });
  if (action.className) {
    $el.addClass(action.className);
  }
  if (action.disabled) {
    $el.attr('disabled', 'true');
  }
  if (action.title) {
    $el.attr('title', action.title);
  }
  return $el;
};

/**
 * Builds dialog html based on params
 * @param {string} title
 * @param {string} body
 * @param {array} actions [ {text: '', callback: function}, ... }
 * @param {boolean} allowClose
 * @param {string} cssClassPrefix
 * @return {jQueryElement} html
 */
var buildDialogHtml = function(title, body, foot, allowClose, cssClassPrefix) {
  var els = [];
  if (allowClose) {
    els.push('<button class="floatShut" href="javascript:;" onclick="$.fn.colorbox.close();"><span class="shift">Close</span></button>');
  }
  if (title) {
    els.push($("<div>").addClass(cssClassPrefix + "Head").append(title));
  }
  if (body) {
    els.push($("<div>").addClass(cssClassPrefix + "Body").html(body));
  }
  if (foot) {
    els.push($("<div>").addClass(cssClassPrefix + "Foot").append(foot));
  }
  var $html = $("<div>")
    .addClass(cssClassPrefix)
    .append(els);
  return $html;
};


// An incomplete attempt is made to prefix non-bookreader api values with _
// Eg. They are only used in jsia, and not part of bookreader configuration.
br = new BookReader();
br.bookId = data.id;
br.zip = data.imageStackFile;
br.subPrefix = data.subPrefix;
br.server = data.server;
br.bookPath = data.subItemPath;
br.imageFormat = data.imageFormat;
br.archiveFormat = data.archiveFormat;
br.bookTitle = data.bookTitle;
br.bookUrl = data.bookUrl;
br.bookUrlText = data.bookUrlText;
br.bookUrlTitle = data.bookUrlTitle;
br.bookUrlMoreInfo = data.moreInfoUrlText;
br.pageProgression = data.pageProgression;
br._use_title_for_side = data.use_title_for_side;
br.imagesBaseURL = data.imagesBaseURL;
br._downloadUrls = data.downloadUrls;
br._olHost = data.olHost;

if ('' !== data.titleLeaf) { /* Output title leaf if marked */
  br.titleLeaf = Number(data.titleLeaf);
}

br._pageW = data.pageW;
br._pageH = data.pageH;
br._leafMap = data.leafMap;
br._pageNums = data.pageNums;
br.numLeafs = br._pageW.length;

// protected attempts to block downloading of images
br.protected = data.lendingInfo.shouldProtectImages;
br._hideOtherFormats = false;

// Build br.metadata which populates the About this book section
br.thumbnail = '//archive.org/download/' + br.bookId + '/page/cover_t.jpg';
br.metadata = [];
br.metadata.push({label: 'Title', value: br.bookTitle, extraValueClass: 'larger'});
if (data.creator) {
  br.metadata.push({label: 'Author', value: data.creator, extraValueClass: 'larger'});
}
if (data.publishDate) {
  br.metadata.push({label: 'Publish Data', value: data.publishDate, extraValueClass: ''});
}
if (data.collection.length > 0) {
  br.metadata.push({label: 'Collections', value: data.collection.join(", "), extraValueClass: ''});
}

br.enableExperimentalControls = true;
br.enablePageResume = true;

// Check for config object
// $$$ change this to use the newer params object
if (typeof(brConfig) != 'undefined') {
  if (typeof(brConfig["ui"]) != 'undefined') {
    br.ui = brConfig["ui"];
  }

  if (brConfig['mode'] == 1) {
    br.mode = 1;
    if (typeof(brConfig['reduce'] != 'undefined')) {
        br.reduce = brConfig['reduce'];
    }
  } else if (brConfig['mode'] == 2) {
    br.mode = 2;
  }

  if (typeof(brConfig["isAdmin"]) != 'undefined') {
    br.isAdmin = brConfig["isAdmin"];
  } else {
    br.isAdmin = false;
  }

  if (typeof(brConfig["theme"]) != 'undefined') {
    br.theme = brConfig["theme"];
  }
} // brConfig


// Default options for BookReader
if (data.bookreaderDefaults) {
  br.defaults = data.bookreaderDefaults;
}

br.getPageWidth = function(index) {
  return this._pageW[index];
}

br.getPageHeight = function(index) {
  return this._pageH[index];
}

// Returns true if page image is available rotated
br.canRotatePage = function(index) {
  return 'jp2' == this.imageFormat; // Assume single format for now
}

// reduce defaults to 1 (no reduction)
// rotate defaults to 0 (no rotation)
br.getPageURI = function(index, reduce, rotate) {
  var _reduce;
  var _rotate;

  if ('undefined' == typeof(reduce)) {
      _reduce = 1;
  } else {
      _reduce = reduce;
  }
  if ('undefined' == typeof(rotate)) {
      _rotate = 0;
  } else {
      _rotate = rotate;
  }

  var file = this._getPageFile(index);

  // $$$ add more image stack formats here
  return '//'+this.server+'/BookReader/BookReaderImages.php?zip='
         + urlencodePath(this.zip)
         + '&file=' + urlencodePath(file)
         + '&scale=' + _reduce + '&rotate=' + _rotate;
}

// _getPageFile is used for BookReader.prototype.getPrintURI
br._getPageFile = function(index) {
  if (index === null) {
    return '';
  }
  var leafStr = '0000';
  var imgStr = String(this._leafMap[index]);
  var re = new RegExp("0{"+imgStr.length+"}$");
  var insideZipPrefix = this.subPrefix.match('[^/]+$');
  var file = insideZipPrefix + '_' + this.imageFormat + '/' + insideZipPrefix +
             '_' + leafStr.replace(re, imgStr) + '.' + this.imageFormat;
  return file;
}

br.getPageSide = function(index) {
  //assume the book starts with a cover (right-hand leaf)
  //we should really get handside from scandata.xml

  // Use special function if we should infer the page sides based off the title page index
  if (this._use_title_for_side) {
    // assume page side based on title pagex
    var titleIndex = br.leafNumToIndex(br.titleLeaf);
    // assume title page is RHS
    var delta = titleIndex - index;
    if (0 == (delta & 0x1)) {
      // even delta
      return 'R';
    } else {
      return 'L';
    }
  }

  // $$$ we should get this from scandata instead of assuming the accessible
  //     leafs are contiguous
  if ('rl' != this.pageProgression) {
    // If pageProgression is not set RTL we assume it is LTR
    if (0 == (index & 0x1)) {
      // Even-numbered page
      return 'R';
    } else {
      // Odd-numbered page
      return 'L';
    }
  } else {
    // RTL
    if (0 == (index & 0x1)) {
      return 'L';
    } else {
      return 'R';
    }
  }
}

br.getPageNum = function(index) {
  var pageNum = this._pageNums[index];
  if (pageNum) {
    return pageNum;
  } else {
    return 'n' + index;
  }
}

// Single images in the Internet Archive scandata.xml metadata are (somewhat incorrectly)
// given a "leaf" number.  Some of these images from the scanning process should not
// be displayed in the BookReader (for example colour calibration cards).  Since some
// of the scanned images will not be displayed in the BookReader (those marked with
// addToAccessFormats false in the scandata.xml) leaf numbers and BookReader page
// indexes are generally not the same.  This function returns the BookReader page
// index given a scanned leaf number.
//
// This function is used, for example, to map between search results (that use the
// leaf numbers) and the displayed pages in the BookReader.
br.leafNumToIndex = function(leafNum) {
  for (var index = 0; index < this._leafMap.length; index++) {
    if (this._leafMap[index] == leafNum) {
      return index;
    }
  }
  return null;
}

// This function returns the left and right indices for the user-visible
// spread that contains the given index.  The return values may be
// null if there is no facing page or the index is invalid.
br.getSpreadIndices = function(pindex) {
  // $$$ we could make a separate function for the RTL case and
  //      only bind it if necessary instead of always checking
  // $$$ we currently assume there are no gaps

  var spreadIndices = [null, null];
  if ('rl' == this.pageProgression) {
    // Right to Left
    if (this.getPageSide(pindex) == 'R') {
      spreadIndices[1] = pindex;
      spreadIndices[0] = pindex + 1;
    } else {
      // Given index was LHS
      spreadIndices[0] = pindex;
      spreadIndices[1] = pindex - 1;
    }
  } else {
    // Left to right
    if (this.getPageSide(pindex) == 'L') {
      spreadIndices[0] = pindex;
      spreadIndices[1] = pindex + 1;
    } else {
      // Given index was RHS
      spreadIndices[1] = pindex;
      spreadIndices[0] = pindex - 1;
    }
  }

  //console.log("   index %d mapped to spread %d,%d", pindex, spreadIndices[0], spreadIndices[1]);

  return spreadIndices;
}

// Remove the page number assertions for all but the highest index page with
// a given assertion.  Ensures there is only a single page "{pagenum}"
// e.g. the last page asserted as page 5 retains that assertion.
br.uniquifyPageNums = function() {
  if (br._pageNums.length == 0)return;
  var seen = {};
  for (var i = br._pageNums.length - 1; i--; i >= 0) {
    var pageNum = br._pageNums[i];
    if ( !seen[pageNum] ) {
      seen[pageNum] = true;
    } else {
      br._pageNums[i] = null;
    }
  }
}

br.cleanupMetadata = function() {
  br.uniquifyPageNums();
}

// getEmbedURL
//________
// Returns a URL for an embedded version of the current book
br.getEmbedURL = function(viewParams) {
  // We could generate a URL hash fragment here but for now we just leave at defaults
  var url = 'https://' + window.location.host + '/stream/'+this.bookId;
  if (this.subPrefix != this.bookId) { // Only include if needed
    url += '/' + urlencodePath(this.subPrefix);
  }
  url += '?ui=embed';
  if (typeof(viewParams) != 'undefined') {
    url += '#' + this.fragmentFromParams(viewParams);
  }
  return url;
}

// getEmbedCode
//________
// Returns the embed code HTML fragment suitable for copy and paste
br.getEmbedCode = function(frameWidth, frameHeight, viewParams) {
  return "<iframe src='" + this.getEmbedURL(viewParams) + "' width='"
          + frameWidth + "' height='" + frameHeight
          + "' frameborder='0' ></iframe>";
}


// Override resume token, to take user into account
//_________
// Get's the page resume value, for remembering reader's page
br.getResumeValue = function() {
  var val = null;
  if (data.lendingInfo.userid)
    val = BookReader.docCookies.getItem('br-resume-' + data.lendingInfo.userid);
  if (val === null)
    val = BookReader.prototype.getResumeValue.call(this);
  if (val !== null)
    val = parseInt(val);
  return val;
}

// Set's the page resume value, for remembering reader's page
br.updateResumeValue = function(index) {
  if (data.lendingInfo.userid) {
    var ttl = new Date(+new Date + 12096e5); // 2 weeks
    var path = window.location.pathname;
    BookReader.docCookies.setItem('br-resume-' + data.lendingInfo.userid, index, ttl, path, null, false);
  } else {
    BookReader.prototype.updateResumeValue.call(this, index);
  }
}


/**
 * Extend buildInfoDiv to add more IA specific fields
 * @param JInfoDiv DOM element. Appends info to this element
 */
var superBuildInfoDiv = br.buildInfoDiv;
br.buildInfoDiv = function(jInfoDiv) {
  superBuildInfoDiv.apply(this, arguments);

  // add download URLS
  if (this._downloadUrls.length > 0 && this._hideOtherFormats === false) {
    var otherFormatsEl = "<div class=\"BRinfoOtherFormats\">"
      + "<div class=\"BRinfoLabel\">Other formats</div>";
    $.each(this._downloadUrls, function(index, row) {
      otherFormatsEl += "<div class=\"BRinfoOtherFormatsFormat\">"
      +   "<a href=\""+row[1]+"\" target=\"_blank\">"
      +     row[0]
      +   "</a>"
      + "</div>";
    });
    otherFormatsEl += "</div>";
    jInfoDiv.find('.BRinfoRightCol').append(otherFormatsEl)
  }

  // fill in footer
  jInfoDiv.find('.BRfloatFoot').append(
    "  <a href=\"https://openlibrary.org/dev/docs/bookreader\" target=\"_blank\">"
    +"    About the BookReader"
    +"  </a>"
    +"  <span class=\"desktop-only\">|&nbsp;&nbsp;</span>"
    +"  <a href=\"mailto:info@archive.org?subject=Book%20Reader%20Feedback\" class=\"problem-icon\" target=\"_blank\">"
    +"    Report a problem"
    +"  </a>"
    +"</div>"
  );
};

// getOpenLibraryRecord
//
// The bookreader is designed to call openlibrary API and constructs the
// "Return book" button using the response.
//
// This makes a call to OL API and calls the given callback function with the
// response from the API.
br.getOpenLibraryRecord = function(callback) {
  // Try looking up by ocaid first, then by source_record
  var self = this; // closure
  var jsonURL = self._olHost + '/query.json?type=/type/edition&*=&ocaid=' + self.bookId;
  $.ajax({
    url: jsonURL,
    success: function(data) {
      if (data && data.length > 0) {
        callback(self, data[0]);
      } else {
        // try sourceid
        jsonURL = self._olHost + '/query.json?type=/type/edition&*=&source_records=ia:' + self.bookId;
        $.ajax({
          url: jsonURL,
          success: function(data) {
            if (data && data.length > 0) {
              callback(self, data[0]);
            }
          },
          dataType: 'jsonp'
        });
      }
    },
    dataType: 'jsonp'
  });
}

/*
 * Update based on received record from Open Library.
 * Open Library record is used for extra metadata, and also for lending
 */
br.gotOpenLibraryRecord = function(self, olObject) {
  // $$$ could refactor this so that 'this' is available
  if (olObject) {
    if (olObject['table_of_contents']) {
      // XXX check here that TOC is valid
      self.updateTOC(olObject['table_of_contents']);
    }
  }
}


/******************************* LENDING ***********************************/

function LendingFlow(br, lendingInfo, tokenPoller) {
  this.br = br;
  this.lendingInfo = lendingInfo;
  this.tokenPoller = tokenPoller;
  this.userid = lendingInfo.userid;

  // Additionally configure book reader
  this.br._hideOtherFormats = true;

  // Used to store the full BR when preview is swapped in
  this.fullBr = null;

  // Bind callbacks to this
  this.handleLoginOk = this.handleLoginOk.bind(this);
  this.handleReadItNow = this.handleReadItNow.bind(this);
  this.handleReturnIt = this.handleReturnIt.bind(this);
  this.handleBorrowFromHold = this.handleBorrowFromHold.bind(this);
  this.handleBorrowIt = this.handleBorrowIt.bind(this);
  this.handleRemoveFromWaitingList = this.handleRemoveFromWaitingList.bind(this);
  this.handleReserveIt = this.handleReserveIt.bind(this);
  this.handleDownloadUrl = this.handleDownloadUrl.bind(this);
};

LendingFlow.prototype.init = function() {
  var self = this;
  var dialogOpts = null;
  var showPreview = true;
  function getQaAction() {
    if (!self.lendingInfo.userHasBorrowed && self.lendingInfo.isAdmin) {
      return {
        text: 'Admin Access',
        callback: function() {
          if (self.isInIframe()) {
            self.handleReadItNow('?admin=1');
          } else {
            self.handleReadItNow('?admin=1');
          }
        },
        className: 'red skinny',
        title: 'You have administrative privileges to read this book'
      };
    } else {
      return null;
    }
  }

  if (get_query_param('admin') == '1' && this.lendingInfo.isAdmin) {
    showPreview = false;
    this.br.init();
  } else if (!this.userid && !this.lendingInfo.isAvailable) {
    dialogOpts = {
      title: "This book is currently on loan.",
      actions: [
        { text: 'Log In and Place Hold', callback: this.handleLoginOk,
          className: 'caution' }
      ]
    };
  } else if (!this.userid) {
    dialogOpts = {
      title: "This book can be borrowed for 14 days.",
      actions: [
        { text: 'Log In and Borrow', callback: this.handleLoginOk,
          className: 'primary' }
      ]
    };
  } else if (this.lendingInfo.userHasBorrowed) {
    // If user loaded this page directly, show the book!
    if (this.isInIframe() === true) {
      var daysLeftStr;
      if (this.lendingInfo.daysLeftOnLoan <= 1) {
        daysLeftStr = "This is the last day of this loan.";
      } else {
        daysLeftStr = "Your loan of this book has "
                      + this.lendingInfo.daysLeftOnLoan
                      + " days left."
      }
      dialogOpts = {
        title: daysLeftStr,
        actions: [
          { text: 'Read it now', callback: this.handleReadItNow,
            className: 'primary' },
          { text: 'Return it', callback: this.handleReturnIt,
            className: 'red' }
        ]
      };
      // Note: Still show preview
    } else {
      // User has access to the book.
      showPreview = false;
      this.initTokenPolling(function() {
        this.addLendingUI();
        this.br.init();
      }.bind(this));
    }
  } else if (this.lendingInfo.userHoldIsReady) {
    var actions = [];
    if (this.lendingInfo.loanCount < this.lendingInfo.maxLoans) {
      actions.push({text: 'Borrow now', callback: this.handleBorrowFromHold, className: 'primary'});
    }
    dialogOpts = {
      title: "This book is on hold for you to borrow.",
      foot: $("<div>").append(
        $("<a>")
          .addClass('muted')
          .attr('href', self.lendingInfo.loansUrl)
          .html("You currently have "+this.lendingInfo.loanCount+" of "
                +this.lendingInfo.maxLoans+" books on loan.")
          .click(function(e) {
            self.goToUrl(self.lendingInfo.loansUrl, true);
            e.preventDefault();
          })
      ),
      actions: actions
    };
  } else if (this.lendingInfo.isAvailable) {
    var disableBorrow = this.lendingInfo.loanCount >= this.lendingInfo.maxLoans;
    var actions;
    if (!disableBorrow) {
      actions = [{ text: 'Borrow This Book', callback: this.handleBorrowIt,
        className: 'primary', disabled: disableBorrow }];
    } else {
      actions = []
    }
    dialogOpts = {
      title: "This book can be borrowed for 14 days.",
      foot: $("<div>").append(
        $("<a>")
          .addClass("muted")
          .attr('href', self.lendingInfo.loansUrl)
          .html("You currently have "+this.lendingInfo.loanCount+" of "
                +this.lendingInfo.maxLoans+" books on loan.")
          .click(function(e) {
            self.goToUrl(self.lendingInfo.loansUrl, true);
            e.preventDefault();
          })
      ),
      actions: actions
    };
  } else if (this.lendingInfo.userOnWaitingList) {
    dialogOpts = {
      title: "You currently have a hold on this book.",
      foot: $('<div>')
        .addClass('muted')
        .text("You will be notified via email when your loan is ready."),
      actions: [
        { text: 'Remove hold',
          callback: this.handleRemoveFromWaitingList,
          className: 'primary' }
      ]
    };
  } else {
    dialogOpts = {
      title: "This book is currently on loan.",
      actions: [
        { text: 'Place a hold', callback: this.handleReserveIt,
          className: 'caution' }
      ]
    };
  }

  if (showPreview === true) {
    // change the book reader to show the preview files instead
    this.swapInPreview();
    this.br.init();
    if (dialogOpts) {
      var qaAction = getQaAction();
      dialogOpts.actions.push(qaAction);
      // 800 is the mobile width media query in css
      if ($(window).width() > 800) {
        dialogOpts.top = 0;
      }
      this.showBookReaderMessage(dialogOpts);
    }
  }
}

/**
 * @return {boolean} is this running in an iframe?
 */
LendingFlow.prototype.isInIframe = function() {
  return isInIframe();
};

/**
 * Helper to get current url with respect to parent frame
 * @global top, eg top.window.location
 * @return {string}
 */
LendingFlow.prototype.getRedirectUrl = function() {
  var url;
  if (this.isInIframe()) {
    // are we in a frame?
    url = top.window.location.href;
  } else {
    url = window.location.href;
  }
  return url;
};

/**
 * Helper function. Loads URL with consideration to parent frame.
 * @param {string} url
 * @param {boolean} tryParent (defaults to undefined)
 */
LendingFlow.prototype.goToUrl = function(url, tryParent) {
  var ref;
  if (this.isInIframe() && tryParent) {
    ref = top.window.location;
  } else {
    ref = window.location;
  }
  if (ref.href === url) {
    ref.reload();
  } else {
    ref.href = url;
  }
};

/**
 * Helper to call loan service
 * @param {Object} options
 */
LendingFlow.prototype.callService = function(options) {
  options = Object.assign({
    action: null,
    data: {},
    success: function() {},
    error: function() {},
    useLoader: true,
  }, options);

  if (options.useLoader) {
    // console.log("this.br.showProgressPopup('Loading...');");
    // this.br.showProgressPopup('Loading...'); // TODO make this work
  }

  var callbackSuccess = function(data, textStatus, jqXHR) {
    if (options.useLoader) {
      // this.br.removeProgressPopup();
    }
    options.success.call(this, data, textStatus, jqXHR);
  }.bind(this);

  var callbackError = function(jqXHR, textStatus, errorThrown) {
    if (options.useLoader) {
      // this.br.removeProgressPopup();
    }
    options.error.call(this, jqXHR, textStatus, errorThrown);
  }.bind(this);

  $.ajax({
    url: "/services/loans/beta/loan/",
    type: "POST",
    dataType: "json",
    data: Object.assign({
      action: options.action,
      identifier: this.br.bookId
    }, options.data),
    timeout: 10000
  }).then(
    callbackSuccess,
    callbackError
  );
};

LendingFlow.prototype.handleLoginOk = function() {
  var target = "/account/login.php?referer=" + encodeURIComponent(this.getRedirectUrl());
  this.goToUrl(target, true);
};

LendingFlow.prototype.handleReadItNow = function(extra) {
  if (!extra) extra = '';
  this.goToUrl("/stream/" + this.br.bookId + extra, true);
};

LendingFlow.prototype.handleReturnIt = function() {
  this.callService({
    action: "return_loan",
    success: function(response) {
      deleteLoanCookies(this.br.bookId);
      this.goToUrl(this.lendingInfo.bookUrl, true);
    }
  });
};

LendingFlow.prototype.handleReserveIt = function() {
  this.callService({
    action: "join_waitlist",
    success: function(response) {
      this.goToUrl(this.getRedirectUrl(), true);
    }
  });
};

LendingFlow.prototype.handleBorrowFromHold = function() {
  this.callService({
    action: "borrow_book",
    success: function(response) {
      this.goToUrl("/stream/" + this.br.bookId, true);
    },
    error: function(response) {
      var msg = response.responseJSON.error || "There was an error";
      alert(msg);
    },
  });
};

LendingFlow.prototype.handleBorrowIt = function() {
  this.callService({
    action: "borrow_book",
    success: function(response) {
      this.goToUrl("/stream/" + this.br.bookId, true);
    },
    error: function(response) {
      var msg = response.responseJSON.error || "There was an error";
      alert(msg);
    },
  });
};

LendingFlow.prototype.handleRemoveFromWaitingList = function() {
  this.callService({
    action: "leave_waitlist",
    success: function(response) {
      this.goToUrl(this.getRedirectUrl(), true);
    }
  });
};

/**
 * Handler for download "pdf" or "epub"
 */
LendingFlow.prototype.handleDownloadUrl = function(format) {
  var url;
  $.each(this.br._downloadUrls, function(index, row) {
    if (row[0] === format) {
      url = row[1];
    }
  });
  if (url) {
    window.open(url, '_blank');
  } else {
    alert("There was an error accessing the requested format: " + format);
  }
}

/**
 * Shows a message above the book reader
 */
LendingFlow.prototype.showBookReaderMessage = function(opts) {
  // Allow building body from actions or passing in directly
  if (opts.actions && opts.actions.length > 0 && !opts.body) {
    opts.body = $.map(opts.actions, buildActionButton);
  }
  opts = Object.assign({
    title: '',
    body: '',
    foot: '',
    allowClose: false,
    top: false,
    cssClassPrefix: 'BookReaderMessage'
  }, opts);

  var $html = buildDialogHtml(opts.title, opts.body, opts.foot,
                                   opts.allowClose, opts.cssClassPrefix);
  $html.appendTo('#IABookReaderMessageWrapper');
  $('#IABookReaderMessageWrapper').css('display', '');
  $(document).trigger('IABookReader:ResizeBookReader');
};

/**
 * Shows a modal dialog
 */
var showDialog = function(opts) {
  // Allow building foot from actions or passing in directly
  if (opts.actions && opts.actions.length > 0 && !opts.foot) {
    opts.foot = $.map(opts.actions, buildActionButton);
  }
  opts = Object.assign({
    title: '',
    body: '',
    foot: '',
    allowClose: false,
    top: false,
    cssClassPrefix: 'center BRfloat'
  }, opts);

  var $html = buildDialogHtml(opts.title, opts.body, opts.foot,
                                   opts.allowClose, opts.cssClassPrefix);

  // Hack to get width influenced by media queries
  var w = $html.css({visibility: 'hidden'}).appendTo('body').width();
  $html.css({visibility: ""}).detach();

  var colorboxOpts = {
    html: $html,
    overlayClose: opts.allowClose,
    escKey: opts.allowClose,
    closeButton: opts.allowClose,
    opacity: 0,
    width: w,
    initialWidth: '300', // lower than mobile
    top: opts.top,
  };
  var cb = $.colorbox(colorboxOpts);
  cb.colorbox.resize();
  return cb;
};


/**
 * Replaces the content with a preview.
 * Note: this.br has not had .init called yet
 */
LendingFlow.prototype.swapInPreview = function() {
  this.fullBr = jQuery.extend(true, {}, this.br);
  this.br.getPageWidth = function(index) {
    return 800;
  }
  this.br.getPageHeight = function(index) {
    return 1200;
  }
  this.br.getPageURI = function(index, reduce, rotate) {
    var images = [
      // 'https://archive.org/download/'+this.bookId+'/page/title_w640.jpg',
      '/bookreader/BookReader/images/transparent.png',
      // 'https://archive.org/download/'+this.bookId+'/page/cover_w640.jpg',
      'https://archive.org/download/'+this.bookId+'/page/title_w640.jpg',
    ];
    return images[index % images.length];
  }
  this.br.getPageNum = function(index) {
    return index+1;
  }
  this.br.getPageSide = function(index) {
    if (1 == (index & 0x1)) {
      return 'R';
    } else {
      return 'L';
    }
  }
  this.br.numLeafs = 2;

  // For "embed" mode to hide controls
  this.br.ui = 'embed';
  // Preview is always in 2-up mode
  this.br.mode = this.br.constMode2up;
  // Disable page resuming
  this.br.enablePageResume = false;
  $('body').addClass('BRPreview');
};


/**
 * Adds the navbar and mobile UI for lending (eg return book, download pdf, etc
 * Needs to be called before this.br.init()
 */
LendingFlow.prototype.addLendingUI = function() {
  var self = this;
  $('body').addClass('BRLending');

  var buildDownloadBody = function() {
    var $downloadBody = $('<div/>');
    if (self.br._downloadUrls.length === 0) {
      $downloadBody.append(
        '<div>We do not have a downloadable copy of this item available.</div>'
      );
      return $downloadBody;
    }

    $downloadBody.append('<div class="ph50-lg">Choose a format to begin your download. '
                        + 'Your loan will last for two weeks.'
                        + '<br/><br/>'
                        + '</div>');

    var downloadActions = $.map(self.br._downloadUrls, function(row) {
      if (row[0] === 'PDF') {
        return {text: '<b>Adobe PDF</b><br><span class="smaller">High Quality Page Images</span>',
         className: 'primary lighter', callback: function() {
           self.handleDownloadUrl('PDF');
        }};
      } else if (row[0] == 'ePub') {
        return {text: '<b>Adobe ePub</b><br><span class="smaller">Smaller File, May Contain Errors</span>',
          className: 'primary lighter', callback: function() {
            self.handleDownloadUrl('ePub');
        }}
      }
    });
    $downloadBody.append($.map(downloadActions, buildActionButton));
    return $downloadBody;
  }

  var buildDownloadFoot = function() {
    var $downloadFoot = $('<div/>');
    if (self.br._downloadUrls.length === 0) {
      return $downloadFoot;
    }
    $downloadFoot.append(buildActionButton({
      text: 'Install Adobe Digital Editions',
      callback: function() {
        window.open('http://www.adobe.com/solutions/ebook/digital-editions/download.html', '_blank');
      }
    }).addClass('orangeButton'));
    $downloadFoot.append('<div class="smaller-lg grey">'
                    + '<br/>'
                    + 'In order to access your downloaded book you will need '
                    + 'Adobe-compliant software on your device. '
                    + 'The Internet Archive will administer this loan, but '
                    + 'Adobe may also collect some information.'
                    + '<br><br>'
                    + '</div>');
    return $downloadFoot;
  }

  var daysLeftStr;
  if (this.lendingInfo.daysLeftOnLoan <= 1) {
    daysLeftStr = "Last day";
  } else {
    daysLeftStr = this.lendingInfo.daysLeftOnLoan + " days left"
  }

  /**
   * Decorate the desktop toolbar method
   */
  this.br.buildToolbarElement = (function(prevBuildToolbarElement) {
    return function() {
      var $el = prevBuildToolbarElement.call(self.br);
      $el.find('.BRtoolbarRight').prepend(
        "<span class='BRtoolbarSection tc ph10'>"
        + "  <a class='BRpill return js-tooltip' href='"+self.lendingInfo.loansUrl+"' title='Return Book (" + daysLeftStr + ")'>"
        + "    <span class='hide-md'>Return Book</span>"
        + "  </a>"
        + "  <a class='BRpill download js-tooltip' href='javascript:;' title='Download PDF/ePub'>"
        + "    <span class='hide-md'>PDF/ePub</span>"
        + "  </a>"
        + "</span>"
      );
      // Bind actions
      $el.find('.BRpill.return').click(function(e) {
        e.preventDefault();
        showDialog({
          title: 'Book Return',
          body: $("<div>")
            .addClass("message")
            .append("<div>You can return a book early here.</div>")
            .append("<div class='mb20'>This will end your current loan of this title.</div>")
            .append(
              $("<a>")
                .attr('href', "#")
                .html("<b>You currently have "+self.lendingInfo.loanCount+" of "
                      +self.lendingInfo.maxLoans+" books on loan.</b>")
                .click(function(e) {
                  self.goToUrl(self.lendingInfo.loansUrl, true);
                  e.preventDefault();
                })
            )
          ,
          allowClose: true,
          actions: [
            {text: 'Cancel', callback: function() {
              $.fn.colorbox.close();
            }},
            {text: 'Return Book', className: 'red', callback: function() {
              self.callService({
                action: "return_loan",
                success: function(response) {
                  deleteLoanCookies(self.br.bookId);
                  self.goToUrl(self.lendingInfo.bookUrl, true);
                }
              });
            }},
          ]
        });
      });

      $el.find('.download').click(function() {
        showDialog({
          title: 'Select Download Format',
          allowClose: true,
          body: buildDownloadBody(),
          foot: buildDownloadFoot(),
        });
      });
      return $el;
    };
  })(this.br.buildToolbarElement);

  // Decorate the mobile drawer method
  this.br.buildMobileDrawerElement = (function(prevBuildMobileDrawerElement) {
    return function() {
      var $el = prevBuildMobileDrawerElement.call(self.br);
      var $ul = $el.children('ul');
      var $newChild = $(
        "<li>"
        +"  <span>"
        +"    <span class=\"DrawerIconWrapper \">"
        +"      <img class=\"DrawerIcon\" src=\""+this.imagesBaseURL+"icon_book.svg\" alt=\"info-book\"/>"
        +     "</span>"
        +"    Loan Information"
        +"  </span>"
        +"  <div id=\"mobileLoanInfo\">"
        +"      <h1>Loan Information</h1>"
        +"      <div>Time Left In Loan Period<br/>"
        +"        <a class='f14' href='"+self.lendingInfo.loansUrl+"'>" + self.lendingInfo.daysLeftOnLoan + " Days</a>"
        +"        <br/><br/>"
        +"      </div>"
        +"  </div>"
        +"</li>"
      );

      $newChild.find('#mobileLoanInfo')
        .append("<div><br/>"
           + "<h1>Book Return</h1>"
           + "<button class='action red return-loan' title='Return Book'>Return Book</button>"
           + "</div>")
        .append("<br/><br/><h1>Download Additional Formats</h1>")
        .append(buildDownloadBody())
        .append("<br/>")
        .append(buildDownloadFoot())
      ;

      $newChild.insertAfter($ul.children().eq(2));

      // Bind actions
      $newChild.find('.return-loan').click(function() {
        if (confirm("Are you sure you want to return this book? "
                    + "This will end your current loan of this title.")) {
          self.handleReturnIt();
        }
      });
      return $el;
    };
  })(this.br.buildMobileDrawerElement);
};

/**
 * @param {Function} callback
 */
LendingFlow.prototype.initTokenPolling = function(callback) {
  this.tokenPoller.init(this, callback);
};

/**
 * Token polling class for Archive.org
 * Init's the token polling mechanism for Archive.org lending
 * Note, we ignore the cookie endpoint url value.
 * Note, the logic is a little confusing. It attempts to auto-fix itself
 *   if token attempt works after failed attempt.
 * It would be nice if the OL code shared this functionality. Not there yet.
 */
var ArchiveOrgTokenPoller = function () {
  this.lendingFlow = null;
};
ArchiveOrgTokenPoller.prototype.init = function(lendingFlow, callback) {
  var tokenInterval, tokenDialog;
  var self = this;
  self.lendingFlow = lendingFlow;
  var pollingDelay = 120000; // 120000 ms == 2 min

  var somethingWentWrong = function(jqXHR, textStatus, errorThrown) {
    var title = 'Connection error';
    var body = 'Please check internet connection.';
    var actions = [
      {text: 'Okay', callback: function() {
        // close, and try again
        weAreBack();
        updateToken();
      }},
    ];
    try {
      // Specific error
      var data = JSON.parse(jqXHR.responseText);
      if (data['error']) {
        title = 'Loan error';
        body = data['error'];
        // Only go back to item button on error
        actions = [{text: 'Back to item details', callback: function() {
          self.lendingFlow.goToUrl(self.lendingFlow.lendingInfo.bookUrl);
        }, className: 'primary'}];
      }
    } catch (e) {}
    tokenDialog = showDialog({
      title: title,
      body: body,
      allowClose: false,
      actions: actions,
    });
  }

  // close a token dialog if open. eg. offline, now back online
  var weAreBack = function() {
    lendingFlow.br.reloadImages();
  }

  var closeTokenDialog = function() {
    if (tokenDialog) {
      try { tokenDialog.colorbox.close(); } catch (e) {}
      tokenDialog = null;
    }
  }

  // do ajax request to token endpoint
  var updateToken = function(callback) {
    lendingFlow.callService({
      action: "create_token",
      success: function(data) {
        closeTokenDialog();
        if (callback !== undefined) {
          callback(data);
        }
      },
      error: function(jqXHR, textStatus, errorThrown) {
        somethingWentWrong(jqXHR, textStatus, errorThrown);
      },
      useLoader: false,
    });
  }

  // Do an initial token, then set an interval
  updateToken(function() {
    callback();
    tokenInterval = setInterval(updateToken, pollingDelay);
  });
}

/**
 * Token polling class for Open Library
 * It uses jsonp to query an endpoint on Open Library.
 * It manually sets cookies.
 */
var OpenLibraryTokenPoller = function() {
  this.lendingFlow = null;
  this.olConnect = false;
  this.loanUUID = false;
  this.permsToken = false;
  this.olHost = null;
  // Note, we hard-code this openlibrary URL, because it gets clobbered by IA.
  this.olAuthUrl = 'https://openlibrary.org/ia_auth/XXX';
};
OpenLibraryTokenPoller.prototype.readInitialCookies = function(bookId) {
  var cookieRe = /;\s*/;
  var cookies = document.cookie.split(cookieRe);
  var length = cookies.length;
  var i;
  for (i=0; i<length; i++) {
    if (0 == cookies[i].indexOf('br-loan-' + bookId)) {
      this.loanUUID = cookies[i].split('=')[1];
    }
    if (0 == cookies[i].indexOf('loan-' + bookId)) {
      this.permsToken = cookies[i].split('=')[1];
    }
    // Set olHost to use if passed in
    if (0 == cookies[i].indexOf('ol-host')) {
      this.olHost = 'https://' + unescape(cookies[i].split('=')[1]);
    }
    // if (0 == cookies[i].indexOf('ol-auth-url')) {
    //   this.olAuthUrl = unescape(cookies[i].split('=')[1]);
    // }
  }
  return this;
};
OpenLibraryTokenPoller.prototype.setTokenCookies = function(bookId, tokenValue) {
  var date = new Date();
  date.setTime(date.getTime()+(10*60*1000));  //10 min expiry
  var expiry = date.toGMTString();
  var cookie = 'loan-'+ bookId +'='+tokenValue;
  cookie    += '; expires='+expiry;
  cookie    += '; path=/; domain=.archive.org;';
  document.cookie = cookie;
  this.permsToken = tokenValue;

  //refresh the br-loan uuid cookie with current expiry, if needed
  if (false !== this.loanUUID) {
    cookie = 'br-loan-'+bookId+'='+this.loanUUID;
    cookie    += '; expires='+expiry;
    cookie    += '; path=/; domain=.archive.org;';
    document.cookie = cookie;
  }
}

OpenLibraryTokenPoller.prototype.callService = function(bookId, success, error) {
  // be sure to add random param to authUrl to avoid stale cache
  var authUrl = this.olAuthUrl.replace("XXX", bookId);
  authUrl = add_query_param(authUrl, 'rand', Math.random());
  if (false !== this.loanUUID) {
    authUrl = add_query_param(authUrl, 'loan', this.loanUUID);
  }
  if (false !== this.permsToken) {
    authUrl = add_query_param(authUrl, 'token', this.permsToken);
  }
  $.ajax({
    url: authUrl,
    dataType: 'jsonp',
    jsonpCallback: 'jsonp_callback',
    success: success,
    error: error,
    timeout: 6000
  });
}

OpenLibraryTokenPoller.prototype.init = function(lendingFlow, callback) {
  var tokenInterval, tokenDialog;
  var self = this;
  var pollingDelay = 120000; // 120000 ms == 2 min
  self.lendingFlow = lendingFlow;

  this.readInitialCookies(self.lendingFlow.br.bookId);

  var somethingWentWrong = function(jqXHR, textStatus, errorThrown) {
    var title = 'Loan error';
    var body = 'There was a error contacting the loan server. Please check your '
            + 'internet connection, or visit the <a href="'
            + self.lendingFlow.lendingInfo.bookUrl
            + '">book page</a> and try again.';
    var actions = [
      {text: 'Okay', callback: function() {
        // close, and try again
        weAreBack();
        updateToken();
      }},
    ];
    try {
      // Specific error
      var data = JSON.parse(jqXHR.responseText);
      if (data['error']) {
        title = 'Loan error';
        body = data['error'];
        actions.push({text: 'Back to item details', callback: function() {
          self.lendingFlow.goToUrl(self.lendingFlow.lendingInfo.bookUrl);
        }, className: 'primary'});
      }
    } catch (e) {}
    tokenDialog = showDialog({
      title: title,
      body: body,
      allowClose: false,
      actions: actions,
    });
  }

  // close a token dialog if open. eg. offline, now back online
  var weAreBack = function() {
    self.lendingFlow.br.reloadImages();
  }

  var closeTokenDialog = function() {
    if (tokenDialog) {
      try { tokenDialog.colorbox.close(); } catch (e) {}
      tokenDialog = null;
    }
  }

  // do ajax request to token endpoint
  var updateToken = function(callback) {
    self.callService(self.lendingFlow.br.bookId, function(data) {
      if (data.token) {
        self.setTokenCookies(self.lendingFlow.br.bookId, data.token);
      }
      closeTokenDialog();
      if (callback !== undefined) {
        callback(data);
      }
    }, function(jqXHR, textStatus, errorThrown) {
      somethingWentWrong(jqXHR, textStatus, errorThrown);
    });
  }

  // Do an initial token, then set an interval
  updateToken(function() {
    closeTokenDialog();
    callback();
    tokenInterval = setInterval(updateToken, pollingDelay);
  });
}

// Extend br.init to call Open Library for TOC
br.init = (function(prevInit) {
  return function() {
    prevInit.call(this);
    if (this.ui !== 'embed') {
      this.getOpenLibraryRecord(this.gotOpenLibraryRecord);
    }
  }
})(br.init);


// Go go go
br.cleanupMetadata();

if (data.lendingInfo.isLendingRequired &&
      data.lendingInfo.isBrowserBorrowable) {
  var tokenPoller;
  if (data.lendingInfo.isOpenLibraryLending) {
    tokenPoller = new OpenLibraryTokenPoller();
  } else {
    tokenPoller = new ArchiveOrgTokenPoller();
  }
  setupRaven();
  var lendingFlow = new LendingFlow(br, data.lendingInfo, tokenPoller);
  lendingFlow.init();
} else {
  /**
   * Decorate the desktop toolbar method
   */
  br.buildToolbarElement = (function(prevBuildToolbarElement) {
    var buildDownloadBody = function() {
      if (data.downloadUrls.length === 0) {
        return $('<div class="pb10">We do not have a downloadable copy of this item available.</div>');
      }
      var $downloadBody = $('<div/>');
      $downloadBody.append('<div class="ph50-lg">Choose a format to begin your download. '
                          + '<br/><br/>'
                          + '</div>');
      // add download URLS
      var otherFormatsEl = "<div class=\"BRinfoOtherFormats\">";
      $.each(data.downloadUrls, function(index, row) {
        otherFormatsEl += "<div class=\"BRinfoOtherFormatsFormat\">"
        +   "<a href=\""+row[1]+"\" target=\"_blank\">"
        +     row[0]
        +   "</a>"
        + "</div>";
      });
      otherFormatsEl += "</div>";
      $downloadBody.append(otherFormatsEl);
      return $downloadBody;
    }
    return function() {
      var $el = prevBuildToolbarElement.call(this);
      if (data.streamOnly) {
        return $el;
      }
      $el.find('.BRtoolbarRight').prepend(
        "<span class='BRtoolbarSection tc ph10'>"
        + "  <a class='BRpill download js-tooltip' href='javascript:;' title='Download PDF/ePub'>"
        + "    <span class='hide-md'>PDF/ePub</span>"
        + "  </a>"
        + "</span>"
      );
      $el.find('.download').click(function() {
        showDialog({
          title: 'Select Download Format',
          allowClose: true,
          body: buildDownloadBody(),
          foot: '',
        });
      });
      return $el;
    };
  })(br.buildToolbarElement);

  br.init();
}

})();
